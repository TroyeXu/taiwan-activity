# 輕量化資料庫選擇分析

## 1. 方案對比總表

| 方案 | 設置複雜度 | 地理支援 | ORM 相容性 | 部署便利性 | 成本 | 推薦度 |
|------|------------|----------|------------|------------|------|--------|
| **SQLite + SpatiaLite** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 免費 | ⭐⭐⭐⭐⭐ |
| PostgreSQL + PostGIS | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 中等 | ⭐⭐⭐ |
| MongoDB | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 低-中 | ⭐⭐ |

## 2. 詳細分析

### 2.1 SQLite + SpatiaLite（強烈推薦）

#### 優勢
```yaml
零配置部署:
  - 單一文件資料庫
  - 無需額外服務器
  - 適合 Vercel/Netlify 部署

輕量高效:
  - 資料庫文件大小: <100MB
  - 查詢速度: 毫秒級
  - 記憶體使用: 最小化

地理功能:
  - SpatiaLite 提供完整 GIS 支援
  - 距離計算、空間查詢
  - 與 PostGIS 功能相近

開發便利:
  - 本地開發無需安裝服務
  - 備份就是複製文件
  - 版本控制友善
```

#### 限制
```yaml
並發限制:
  - 適合讀多寫少場景
  - 同時寫入限制

擴展性:
  - 單一文件限制
  - 不適合超大規模應用

功能限制:
  - 沒有用戶權限系統
  - 觸發器功能有限
```

#### 實作範例
```typescript
// drizzle.config.ts
export default {
  schema: './db/schema.ts',
  out: './db/migrations',
  driver: 'better-sqlite',
  dbCredentials: {
    url: './data/tourism.db'
  }
} satisfies Config;

// 地理查詢範例
const nearbyActivities = await db.execute(sql`
  SELECT a.*, l.*, 
    Distance(
      MakePoint(${userLng}, ${userLat}, 4326),
      MakePoint(l.longitude, l.latitude, 4326)
    ) / 1000 as distance_km
  FROM activities a
  JOIN locations l ON a.id = l.activity_id
  WHERE Distance(
    MakePoint(${userLng}, ${userLat}, 4326),
    MakePoint(l.longitude, l.latitude, 4326)
  ) / 1000 <= ${radiusKm}
  ORDER BY distance_km
`);
```

### 2.2 PostgreSQL + PostGIS（企業級選擇）

#### 優勢
```yaml
功能完整:
  - 完整的 SQL 標準支援
  - 強大的地理空間功能
  - 複雜查詢優化

擴展性:
  - 支援大量並發
  - 橫向擴展能力
  - 企業級可靠性

生態系統:
  - 豐富的擴展插件
  - 完整的監控工具
  - 成熟的備份方案
```

#### 劣勢
```yaml
複雜度高:
  - 需要額外服務器管理
  - 配置複雜
  - 部署成本高

資源需求:
  - 記憶體使用較高
  - 磁碟空間需求大
  - 需要專業維護
```

### 2.3 MongoDB（文檔型選擇）

#### 優勢
```yaml
靈活性:
  - Schema-less 設計
  - JSON 原生支援
  - 快速迭代開發

雲端友善:
  - MongoDB Atlas 托管服務
  - 自動擴展
  - 內建安全功能
```

#### 劣勢
```yaml
地理功能:
  - GeoJSON 支援有限
  - 複雜空間查詢較弱
  - 距離計算精度不如 PostGIS

學習成本:
  - NoSQL 查詢語法
  - 索引設計考量
  - 關聯查詢複雜
```

## 3. ORM 選擇分析

### 3.1 Drizzle ORM（推薦）

```typescript
// 型別安全、效能優異
import { eq, and, sql } from 'drizzle-orm';

// 簡潔的查詢語法
const activities = await db
  .select()
  .from(activitiesTable)
  .where(
    and(
      eq(activitiesTable.status, 'active'),
      sql`${activitiesTable.createdAt} > ${yesterday}`
    )
  );
```

**優勢：**
- TypeScript 原生支援
- 零 runtime overhead
- SQL-like 語法直觀
- 輕量級，打包體積小

### 3.2 Prisma（功能豐富）

```typescript
// 功能完整但相對較重
const activities = await prisma.activity.findMany({
  where: {
    status: 'active',
    createdAt: {
      gte: yesterday
    }
  },
  include: {
    location: true,
    categories: true
  }
});
```

**優勢：**
- 圖形化介面
- 自動遷移
- 型別自動生成

**劣勢：**
- 打包體積較大
- Runtime 依賴多

### 3.3 TypeORM（企業級）

**優勢：**
- 裝飾器語法
- 功能最完整
- 支援多種資料庫

**劣勢：**
- 學習曲線陡峭
- 配置複雜
- 較重的框架

## 4. 針對觀光地圖的最佳選擇

### 4.1 推薦方案：SQLite + Drizzle

```typescript
// 完整的實作範例
// db/schema.ts
export const activities = sqliteTable('activities', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  description: text('description'),
  status: text('status').default('active'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

export const locations = sqliteTable('locations', {
  id: text('id').primaryKey(),
  activityId: text('activity_id').references(() => activities.id),
  address: text('address').notNull(),
  latitude: real('latitude').notNull(),
  longitude: real('longitude').notNull(),
});

// server/api/activities/nearby.get.ts
export default defineEventHandler(async (event) => {
  const { lat, lng, radius = 10 } = getQuery(event);
  
  const nearbyActivities = await db.execute(sql`
    SELECT 
      a.*,
      l.address,
      l.latitude,
      l.longitude,
      Distance(
        MakePoint(${lng}, ${lat}, 4326),
        MakePoint(l.longitude, l.latitude, 4326)
      ) / 1000 as distance_km
    FROM activities a
    JOIN locations l ON a.id = l.activity_id
    WHERE a.status = 'active'
      AND Distance(
        MakePoint(${lng}, ${lat}, 4326),
        MakePoint(l.longitude, l.latitude, 4326)
      ) / 1000 <= ${radius}
    ORDER BY distance_km
    LIMIT 50
  `);
  
  return nearbyActivities;
});
```

### 4.2 資料量評估

```yaml
預估資料量:
  - 活動資料: 10,000 筆 (~5MB)
  - 地點資料: 10,000 筆 (~3MB)
  - 分類關聯: 20,000 筆 (~1MB)
  - 索引文件: (~5MB)
  - 總計: ~15MB

SQLite 適用範圍:
  - 資料量: < 1TB (遠超需求)
  - 並發讀取: 數千個連接
  - 查詢效能: 毫秒級回應
```

## 5. 實際部署考量

### 5.1 Vercel 部署限制

```yaml
Vercel Limitations:
  - Serverless Functions: 50MB 限制
  - 執行時間: 10s 限制 (Hobby), 5min (Pro)
  - 記憶體: 1GB 限制
  
SQLite 相容性:
  - 文件大小: ✅ (<50MB)
  - 讀取效能: ✅ (毫秒級)
  - 無持久寫入: ⚠️ (讀多寫少場景適用)
```

### 5.2 替代方案（如需寫入頻繁）

```yaml
Vercel + PlanetScale:
  - MySQL 相容
  - Serverless 架構
  - 自動擴展
  - 地理查詢支援 (MySQL 8.0+)

Vercel + Supabase:
  - PostgreSQL + PostGIS
  - RESTful API
  - 即時訂閱功能
  - 免費額度充足
```

## 6. 最終建議

### 🎯 階段性實作策略

**第一階段：MVP (SQLite + Drizzle)**
- 快速開發和部署
- 零配置，專注功能開發
- 驗證產品可行性

**第二階段：擴展 (視需求選擇)**
- 如果讀寫比例合適：繼續 SQLite
- 如果需要高並發寫入：遷移到 PlanetScale
- 如果需要複雜地理查詢：升級到 PostgreSQL

### 💰 成本比較

```yaml
SQLite + Drizzle:
  - 開發成本: 最低
  - 維護成本: 最低
  - 部署成本: 免費 (Vercel)

PlanetScale:
  - 開發成本: 低
  - 維護成本: 低
  - 部署成本: $29/月起

PostgreSQL 自管:
  - 開發成本: 中等
  - 維護成本: 高
  - 部署成本: $20-100/月
```

**結論**：對於您的觀光活動地圖需求，**SQLite + Drizzle** 是最適合的選擇，提供了完美的輕量化、功能性和開發效率平衡。